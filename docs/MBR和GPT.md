**MBR和GPT**

参考：

<https://juejin.cn/post/6844903664235069454>

<https://www.zhihu.com/question/21672895>

**分区表格式**

当使用硬盘的时候，我们并不是直接从头写入。当分区之后我们可以进行更好的文件组织管理，同时提高资源的利用率\~\~参见虚拟化的好处\~\~.

从功能上看,一个分区表承担着记录分区位置和标记可启动系统的任务.

**MBR**

上一代分区表格式,由硬盘的第一个扇区储存\~\~当然扇区的叫法来自于机械硬盘,不过这里只是计量单位\~\~,包含了主引导记录(MBR),数据区,分区表(最多四个)和结束标志.

**结构**

  ----------------------------------- -----------------------------------
  hex                                 data

  0x0000-0x0088                       Mater Boot Record

  0x0089-0x01BD                       出错信息数据

  0x01BE-0x01CD                       分区1信息

  0x01CE-0x01DD                       分区2信息

  0x01DE-0x01ED                       分区3信息

  0x01EE-0x01FD                       分区4信息

  0x01FE                              0x55

  0x01FF                              0xAA
  ----------------------------------- -----------------------------------

系统启动依靠MBR块的引导程序,从而启动有启动标志的分区.

分区包含的信息有引导标志,分区类型,分区位置(起始和结束位置),以及总大小,(这里用的是CHS模式,用的物理地址)

MBR最后的是结束位,如果没有就会出错

**缺点**

同时,由于数据大小的严格限制,MBR最大表示8G的硬盘,但是由于这个实在是太小了,通过一些办法(用LBA模式,通过逻辑地址直接寻址,)将最大调整到2T~~虽然还是很小~~

但是MBR最大仍然只支持4个分区,为了解决这个问题,使用了扩展分区的方式(用类似链表的方式),但是这也导致一个问题就是一旦一个分区寄了,剩下的分区也可能会寄.而且由于引导程序大小在MBR块里头也是严格限定的,所以如果安装在逻辑分区的系统不能被直接引导.

**注意事项**

现代的存储盘超过2T已经很常见了,win10,win11的操作系统也基本上放弃了MBR分区格式,所以如果要装系统的话,一定注意不要使用MBR分区格式(因为有些盘刚买到手上的时候会被识别为MBR分区表\~\~不知道是真是还是DG有问题\~\~).

可以使用各种工具把MBR转成GPT,在[DG](https://diskgenius.cn/help/convertpt.php)里是\'转换分区表类型为GUID\'格式,微软的[diskpart](https://learn.microsoft.com/zh-cn/windows-server/storage/disk-management/change-an-mbr-disk-into-a-gpt-disk#:~:text=%E5%9C%A8%20DISKPART%20%E6%8F%90%E7%A4%BA%E7%AC%A6%E4%B8%8B%EF%BC%8C%E8%BE%93%E5%85%A5%20select%20disk%20%3Cdisk-number%3E%20%EF%BC%8C%E5%85%B6%E4%B8%AD%20%3Cdisk-number%3E,%E6%8F%90%E7%A4%BA%E7%AC%A6%E4%B8%8B%EF%BC%8C%E8%BE%93%E5%85%A5%20convert%20gpt%20%E4%BB%A5%E5%B0%86%20MBR%20%E7%A3%81%E7%9B%98%E8%BD%AC%E6%8D%A2%E4%B8%BA%20GPT%20%E5%88%86%E5%8C%BA%E6%A0%BC%E5%BC%8F%E3%80%82)也可以在命令行实现

**GPT**

这是目前广泛使用的分区表格式,\~\~同时他也留下保护区给MBR\~\~.

GPT的分区开头会空一个扇区的大小,用来兼容MBR(如果你用过一些分区工具看到开头空了一点点,原因就是这个了)

在最后GPT分区表也会空几个扇区用来备份分区表(这就是为什么你最后一点点也分不干净)

起始信息区结构

  ----------------------------------- -------------------------------------------
  字节偏移量                          内容

  0x00-0x07                           GPT签名\"EFI PART\"

  0x08-0x0B                           版本号

  0x0C-0x0F                           EFI信息区大小

  0x10-0x13                           GPT头CRC校验和

  0x14-0x17                           留空

  0x18-0x1F                           EFI信息区的起始扇区号

  0x20-0x27                           备份位置的扇区号

  0x28-0x2F                           分区的起始扇区号

  0x30-0x37                           GPT分区的结束区扇区号

  0x38-0x47                           磁盘的GUID

  0x48-0x4F                           分区表的起始扇区号

  0x50-0x53                           分区表总个数(是的,可以自定义的),默认128个

  0x54-0x57                           每个分区表的大小,通常是128个字节

  0x58-0x5B                           分区表CRC校验和
  ----------------------------------- -------------------------------------------

分区表结构

  ----------------------------------- -----------------------------------
  相对偏移量                          内容

  0x00-0x0F                           GUID表示的分区类型

  0x10-0x1F                           GUID表示的唯一标识符

  0x20-0x27                           起始扇区,用LBA表示

  0x28-0x2F                           结束扇区,用LBA表示

  0x30-0x37                           分区的属性标志

  0x38-0x7F                           UTF-16LE的分区名称
  ----------------------------------- -----------------------------------

分区类型GUID被各个系统用于特殊用途,比如linux的home分区是有一个固定的GUID的,可以在不被fstab定义的情况下自动挂载.

EFI的区域有以下内容

EFI信息区(GPT头),来定义分区表的大小,并且存储了校验码.

分区表,分区表中的每个分区项由起始地址、结束地址、类型值、名字、属性标志、GUID值(分区全局ID)组成,EFI的分区表个数是可以扩展的(上面可以自定义分区表的大小),默认存储128个分区表.

GPT分区,实际上的存放分区的地方

备份区,就是上面的那个最后的几个扇区,一共33个,备份了EFI信息区和分区表

所以从任何角度上看,GPT都是比MBR先进的,包括在可拓展性上和数据安全性上.

**ESP分区**

ESP分区(EFI系统分区)存储着启动需要的.efi文件,代替主引导记录的功能.通过一个分区类型GUID进行标志.在UEFI启动时启动其中的.efi文件(得益于UEFI统一接口).

一个问题就在于,按照标准,如果一个ESP分区里有linux和win的.efi,那么在UEFI设置里头是可以设置启动项的,但是微软这个asshole,

首先不会允许bootmgr.efi启动非win系统,

会在更新的时候偷摸UEFI启动项不停把自己设置成默认项,

会把bootx64.efi这一通用启动文件偷摸成自己的,

会和硬件厂商进行py交易,把默认引导项从bootx64改成bootmgfw.efi

还有就是secure
boot的数字签名一共就几个公司提供(对一般用户我认为没什么用其实)
