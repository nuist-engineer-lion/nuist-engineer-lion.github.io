# 计算机启动过程

参考：

- <https://ruanyifeng.com/blog/2013/02/booting.html>
- <https://www.runoob.com/linux/linux-system-boot.html>
- <https://learn.microsoft.com/en-us/windows-hardware/drivers/bringup/boot-and-uefi>

<!-- more -->

开机是很复杂的事情...

## boot

这是一个拉着鞋带把自己提起来的过程

> "pull oneself up by one's bootstraps"

也就是计算机启动要做的是把程序装入内存，而把程序装入内存需要运行程序。这件事情是很矛盾的，也就是一个*拉鞋带*的过程

## BIOS

为了解决这个问题，我们有ROM这么一个东西，用一块ROM芯片存储基本输入输出系统（Basic Input/Output System）称为BIOS，当然现代的UEFI BIOS很高级，可扩展性和通用性也变高了,最直观的地方就是可以运行GUI了。传统BIOS运行在16实模式下，也就是最早的8088时期搞出来的东西，功能是有限的。但是UEFI是64位运行的，并能安全启动。

### 自检

BIOS上来第一件事情就是自建，简称POST，如果自检不通过或者有问题一般也会有相应的方式进行报告，每种主机不一样，可能是闪灯也可能是蜂鸣器。

~~我之前遇到过一个逆天电脑，硬盘都寄了还能启动，几秒过后直接黑屏，所以自检不是能发现所有问题的~~UEFI弱化了开机自检功能

### 交给下一级

BIOS只是一个基本系统（当然现在的bios做的高级，但也不能直接当系统用），实际运行的系统需要由BIOS来拉起，并把设备控制权交给他，也就是BIOS中的启动顺序设置

## 引导

这里分两个讲，一个是legacy，一个是UEFI

### legacy

MBR是主引导记录，使用的启动模式叫legacy，BIOS会读取存储设备的第一个扇区，一共512个bit，在第一个扇区末尾两个字节是0x55和0xAA作为可启动标志

MBR里有这些东西

> (1) 第1-446字节：调用操作系统的机器码。
> (2) 第447-510字节：分区表（Partition table）。
> (3) 第511-512字节：主引导记录签名（0x55和0xAA）。

MBR同时也可以做分区表使用，每个分区使用16个字节，但是只能分四个主分区，且单个分区不超过2T 。

每个分区信息里包括：是否可启动分区，第一个扇区物理位置，分区类型，最后一个扇区物理位置，第一个扇区的物理位置，扇区总数

### UEFI

这是legacy启动的继任者。

事实上，UEFI和legacy在BIOS阶段就不一样了，UEFI　BIOS和ＰＣ　BIOS是不一样的.。

UEFI使用的GPT分区，GPT分区表可以支持9.44ZB的存储空间。他会将分区信息存在EFI分区里。

GPT分区的信息包括：类型GUID，分区GUID，其实物理位置，末尾物理位置，属性标签，分区名

（整个UEFI有七个阶段）

UEFI模式最终会启动一个.efi的可执行文件。

## 硬盘启动

UEFI下已经可以在EFI分区下完成这个功能了

### 卷记录引导

legacy会依靠MSR里的启动标志选择下一步启动的操作系统位置。

### 启动管理器

这里分成windows和grub。当然，有UEFI之后，启动管理器可以直接放在EFI分区里头，而启动的仍然是efi可执行程序

#### Windows

启动的是bootmgr.efi，也有用于放各种语言版本的分目录之类的目录结构

#### grub

启动的是Bootx64.efi，然后目录里也有grub.cfg用来当配置文件

## 操作系统

这里就启动内核了，要分成win和linux，这里就只讲linux吧，~~不知道win在暗地里摸了些什么~~

### linux

在boot目录下面有一个内核，启动linux的第一步就是把内核扔进内存里。接下来，根据守护进程的管理方式不同，会有一些细微的差别。原来的是通过init程序根据/etc下面的启动配置文件用来启动init进程，现在也有systemd之类的管理工具进行管理。最初运行的守护进程的pid就会为1~~经典面试题耶~~。

## 后记

其实我写的是很概括的，计算机启动的每一步单拿出来都是大工程，人类科技发展到今天实在是非常可怕的。
